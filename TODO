 * submit patch for libglib (initialization when
   linking statically with win32 threads - see glib/glib-init.c).
   Also gspawn helpers should probably link with -all-static when compiling
   a static glib. Why would be build a static glib but have the programs
   depend on other libraries?
 * Wiki page about creating and maintaining lexer configurations.
   Also mention how to use the "lexer.test..." macros in the
   "edit" hook.
 * OS X port (macports and/or homebrew)

Known Bugs:
 * Colors are still wrong in Linux console even if TERM=linux-16color
   when using Solarized. Affects e.g. the message line which uses the
   reverse of STYLE_DEFAULT.
   Perhaps we must call init_color() before initializing color pairs
   (currently done by Scinterm).
 * session.save should save and reset ^R. Perhaps ^R should be
   mapped to a Q-Reg to allow [^R. Currently, saving the buffer session
   fails if ^R != 10.
   On the other hand, given that almost any macro depends on the
   correct radix, __every__ portable macro would have to save the
   old radix. Perhaps it's better to make the radix a property of the
   current macro invocation frame and guarantee ^R == 10 at the beginning
   of macros.
 * Null-byte in strings not always handled transparently
 * Saving another user's file will only preserve the user when run as root.
   Generally, it is hard to ensure that a) save point files can be created
   and b) the file mode and ownership of re-created files can be preserved.
   We should fall back silently to an (inefficient) memory copy or temporary
   file strategy if this is detected.
 * crashes on large files: S^EM^X$ (regexp: .*)
 * the glib allocators are fundamentally broken:
   throwing exceptions is unsafe from C-linkage callbacks.
   We should abandon the custom allocators and rely on
   SciTECO's memory limiting.
 * It is still possible to crash SciTECO using recursive functions,
   since they map to the C++ program's call stack.
   It is perhaps best to use another ValueStack as a stack of
   macro strings and implement our own function calling.
 * SciTECO crashes can leave orphaned savepoint files lying around.
   Unfortunately, both the Windows and Linux ways of deleting files
   on close cannot be used here since that would disallow cheap
   savepoint restoration.
   On Windows we could work around this using
   MoveFileEx(file, NULL, MOVEFILE_DELAY_UNTIL_REBOOT)

Features:
 * Numbers could be separate states instead of stack operating
   commands. The current behaviour has few benefits.
   If a number is a regular command that stops parsing at the
   first invalid character in the current radix, we could write
   hexadcimal constants like 16^R0BEEF^D (still clumsy...)
 * Function key masking flag for the beginning of the command
   line. May be useful e.g. for solarized's F5 key (i.e. function
   key macros that need to terminate the command line as they
   cannot be rubbed out properly).
 * Some command to query the dirty-status of buffers (e.g. EJ).
   This allows us to save all modified buffers. See #4.
 * Mouse support. Not that hard to implement. Mouse events
   use a pseudo function key macro as in Curses.
   Using some special command, macros can query the current
   mouse state (this maps to an Interface method).
 * Support loading from stdin (--stdin) and writing to
   the current buffer to stdout on exit (--stdout).
   This will make it easy to write command line filters,
   This also means we need something like --ed to set the
   ED flags before everything else and --quiet.
   Command line arguments should then also be handled
   differently.
 * The C/C++ lexer supports preprocessor evaluation.
   This is currently always enabled but there are no defines.
   Could be added as a global reg to set up defines easily.
 * Now that we have redo/reinsertion:
   When ^G modifier is active, normal inserts could insert
   between effective and rubbed out command line - without
   resetting it. This would add another alternative to { and }
   for fixing up a command line.
 * some missing useful VideoTECO/TECO-11 commands:
   * EF with buffer id
   * ER command: read file into current buffer at dot
   * $$, ^C: return from macro. $ should probably be a "complex"
     command with two states, whereas the second character
     determines the action. This will also improve command-line
     termination which is now sometimes too early.
     A lookahead is possible for "$" since it does not have
     to be executed immediately - there's no side-effect visible
     to the user until the second key has been pressed.
 * nEW to save a buffer by id
 * use CRTP for RBTrees to avoid unnecessary virtual method calls.
   This means that like the original BSD headers, implementations
   of the rbtree ops will be generated for every usage.
   Since currently, only QRegister tables and goto tables are
   RBTrees, the binary size overhead should be minimal.
   There's another possible optimization: RBTrees define an entry
   field for storing node color. This can be avoided on most
   platforms where G_MEM_ALIGN > 1 by encoding the color in the
   lowest bit of one of the pointers.
   The parent pointer is not required for RBTrees in general,
   but we do use the PREV/NEXT ops to iterate prefixes which requires
   the parent pointer to be maintained.
 * Buffer ids should be "circular", i.e. interpreted modulo the
   number of buffers in the ring. This allows "%*" to wrap at the
   end of the buffer list.
 * instead of 0EB to show the list of buffers, there should perhaps
   be a special TAB-completion (^G mode?) that completes only buffers
   in the ring. It should also display the numeric buffer ids.
 * properly support Unicode encodings and the character-based model
   * link against libncursesw if possible
   * translate documents to Unicode strings
   * a position refers to a character/codepoint
 * Progress indication in commandline cursor:
   Perhaps blinking or invisible?
 * Command to free Q-Register (remove from table).
   e.g. FQ (free Q). :FQ could free by QRegister prefix name.
 * autocompletion of long Q-Reg names
 * TECO syntax highlighting
 * multiline commandline
   * perhaps use Scintilla view as mini buffer.
     This means patching Scintilla, so it does not break lines
     on new line characters.
   * A Scintilla view will allow syntax highlighting
 * command line could highlight dead branches (e.g. gray them out)
 * improve GTK interface
   * proper command-line widget (best would be a Scintilla view, s.a.)
   * speed improvements
   * STYLE_DEFAULT and STYLE_CALLTIP should be used for styling the
     info, message, command line and popup widgets just as the Curses
     UI does.
 * backup files, or even better Journal files:
   could write a Macro file for each modified file containing
   only basic commands (no loops etc.). it is removed when the file is
   saved. in case of an abnormal program termination the
   journal file can be replayed. This could be done automatically
   in the profile.
 * Add special Q-Register for dot:
   Would simplify inserting dot with string building and saving/restoring
   dot on the QReg stack
 * :EL command could also be used to convert all EOLs in the current
   buffer.
 * exclusive access to all opened files/buffers (locking):
   SciTECO will never be able to notice when a file has been
   changed externally. Also reversing a file write will overwrite
   any changes another process could have done on the file.
   Therefore open buffers should be locked using the flock(), fcntl()
   or lockf() interfaces. On Windows we can even enforce mandatory locks.
 * Touch restored save point files - should perhaps be configurable.
   This is important when working with Makefiles, as make looks
   at the modification times of files.
 * At least on Windows we could implement file restoration via
   filesystem forks (called Alternate Data Streams) and fall back
   to the generic savepoint file solution if this is not possible
   (e.g. on a FAT32 drive).
 * Instead of implementing split screens, it is better to leave
   tiling to programs dedicated to it (tmux, window manager).
   SciTECO could create pseudo-terminals (see pty(7)), set up
   one curses screen as the master of that PTY and spawn
   a process accessing it as a slave (e.g. urxvt -pty-fd).
   Each Scintilla view could then be associated with at most
   one curses screen.
   GTK+ would simply manage a list of windows.
 * Add a command for manipulating the clipboard.
   Can be done with ECxclip$ on Unix, but other platforms have
   better methods (e.g. PDCurses has clipboard extensions, GTK+
   has native clipboard support). On ncurses/UNIX we can fall back
   to spawning xclip or copy xclip's functionality.
   Unfortunately, not every UNIX has X11 (e.g. linux console,
   OS X). What do we do on those systems?
   This will also allow us to reverse clipboard modifications.
 * Add a test suite. Most bugs can be tested for regressions
   using a simple test suite that calls sciteco.
   Use Autotest for instance.

Optimizations:
 * Support link-time-optimization for Scintilla and SciTECO.
   This could significantly improve performance esp. when linking
   in everything statically as is done on Windows.
 * Instead of using RTTI to implement the immediate editing command
   behaviours in Cmdline::process_edit_cmd() depending on the current
   state, this could be modelled via virtual methods in State.
   This would almost eradicate Cmdline::process_edit_cmd() and the
   huge switch-case statement, would be more efficient (but who cares
   in this case?) and would allow us to -fno-rtti saving a few bytes.
   However, this would mean to make some more Cmdline methods public and
   it distributes command line behaviour all over SciTECO instead of
   concentrating it in the Cmdline class...
 * C++14 is supported by GCC 5 and supports new() and delete()
   operators with a size argument. Replacing these operators
   with versions using g_slice_alloc() and g_slice_free() should
   speed up things, especially Q-Register handling and the undo
   stack.
   This compiler capability should be checked by the build system.
   C++11 already allows sized allocators in a class.
   Testing shows that this does not speed up things on Linux
   and prevents freeing memory on command line termination
   (it would be glibc-specific).
   We should test whether it brings any benefit on Windows
   and implement with a build-time option.
 * String::append() could be optimized by ORing a padding
   into the realloc() size (e.g. 0xFF).
   However, this has not proven effective on Linux/glibc
   probably because it will already allocate in blocks of
   roughly the same size.
   Should be tested on Windows, though.
 * Scintilla: SETDOCPOINTER resets representations, so we
   have to set SciTECO representations up again often.
   This should be patched in Scintilla.
 * commonly used (special) Q-Registers could be cached,
   saving the q-reg table lookup
 * refactor search commands (create proper base class)
 * refactor match-char state machine using MicroStateMachine class
 * simplify parser (static jump tables are unnecessary!)
 * search and other commands can be significantly optimized:
   in batch mode, or in loops/macros there is no need to rematch every character!
   -> immediate vs. non-immediate command execution
   * can be handled automatically in StateExpectString
   * but it requires to be able to determine whether we're in the
     command line macro stack frame and are executing the end of it.
 * batch mode can be optimized by preventing unnecessary allocations/deallocations
   for UNDO token creation. Check for undo.enabled in constructors like
   undo.push_msg|var() where the undo token destruction does not have any
   significant side effects.

Documentation:
 * Code docs (Doxygen). It's slowly getting better...
 * clean up/fix generate-docs.tes
   generate-docs.tes could be turned into a general purpose script to
   extract command and macro documentation from C and SciTECO code.
   It should then be installed so it may be used by third-party macro
   library authors as well.
 * An online help system based on manpages/Troff documents.
   The internal commands and macro libraries are continued to be
   documented using man-pages (perhaps generated via generate-docs.tes).
   These troff documents can be augmented with SciTECO-specific tagging
   troff macros which are invisible when processed by man/grotty.
   Online documentation could be generated using a new dedicated
   groff post-processor that generates SciTECO macros that fill a
   buffer with the formatted text and style it. Let's call the roffed
   documentation page a "womanpage" and the post-processor "womanizer".
   While the source document will usually be man or mandoc, this would
   allow writing online documentation using any troff macro package
   and for simple documentations, the "womanpage" can be coded directly
   in SciTECO.
   SciTECO will support a new interactive-mode-only command (e.g. ^H)
   that loads a "womanpage" by consulting a tag index, that is built
   up when interactive mode boots and links a tag to a "womanpage" file
   (allowing tab completion of course).
   The "womanpage" macro not only builds up the formatted page when
   executed but also a tag table that associates individual tags with
   buffer positions. After the "womanpage" has been munged, SciTECO
   consults this table to jump to the correct position.
   The "womanizer" script is distributed as well, to allow third party
   macro authors to properly document their macros by manpage and
   only-help.
   The nice thing about this scheme is that groff is not required
   at run time since tagged womanpages are generated at build time.
