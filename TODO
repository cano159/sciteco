 * submit patch for libglib (initialization when
   linking statically with win32 threads - see glib/glib-init.c).
   Also gspawn helpers should probably link with -all-static when compiling
   a static glib. Why would be build a static glib but have the programs
   depend on other libraries?
 * Wiki page about creating and maintaining lexer configurations.
   Also mention how to use the "lexer.test..." macros in the
   "edit" hook.
 * OS X port (macports and/or homebrew)

Known Bugs:
 * 0A at end of buffer should fail
 * Null-byte in strings not always handled transparently
 * Saving another user's file will only preserve the user when run as root.
   Generally, it is hard to ensure that a) save point files can be created
   and b) the file mode and ownership of re-created files can be preserved.
   We should fall back silently to an (inefficient) memory copy or temporary
   file strategy if this is detected.
 * crashes on large files: S^EM^X$ (regexp: .*)
 * the glib allocators are fundamentally broken:
   throwing exceptions is unsafe from C-linkage callbacks.
   We should abandon the custom allocators and rely on
   SciTECO's memory limiting.
 * It is still possible to crash SciTECO using recursive functions,
   since they map to the C++ program's call stack.
   It is perhaps best to use another ValueStack as a stack of
   macro strings and implement our own function calling.

Features:
 * Use "SHUT_DOWN" function key on PDCurses/Win32a (see pdcwin.h).
 * Some command to query the dirty-status of buffers (e.g. EJ).
   This allows us to save all modified buffers. See #4.
 * Mouse support. Not that hard to implement. Mouse events
   use a pseudo function key macro as in Curses.
   Using some special command, macros can query the current
   mouse state (this maps to an Interface method).
 * Support loading from stdin (--stdin) and writing to
   the current buffer to stdout on exit (--stdout).
   This will make it easy to write command line filters,
   This also means we need something like --ed to set the
   ED flags before everything else and --quiet.
   Command line arguments should then also be handled
   differently.
 * The C/C++ lexer supports preprocessor evaluation.
   This is currently always enabled but there are no defines.
   Could be added as a global reg to set up defines easily.
 * Now that we have redo/reinsertion:
   When ^G modifier is active, normal inserts could insert
   between effective and rubbed out command line - without
   resetting it. This would add another alternative to { and }
   for fixing up a command line.
 * some missing useful VideoTECO/TECO-11 commands:
   * EF with buffer id
   * ER command: read file into current buffer at dot
   * $$, ^C: return from macro. $ should probably be a "complex"
     command with two states, whereas the second character
     determines the action. This will also improve command-line
     termination which is now sometimes too early.
     A lookahead is possible for "$" since it does not have
     to be executed immediately - there's no side-effect visible
     to the user until the second key has been pressed.
 * nEW to save a buffer by id
 * use CRTP for RBTrees to avoid unnecessary virtual method calls.
   This means that like the original BSD headers, implementations
   of the rbtree ops will be generated for every usage.
   Since currently, only QRegister tables and goto tables are
   RBTrees, the binary size overhead should be minimal.
   There's another possible optimization: RBTrees define an entry
   field for storing node color. This can be avoided on most
   platforms where G_MEM_ALIGN > 1 by encoding the color in the
   lowest bit of one of the pointers.
   The parent pointer is not required for RBTrees in general,
   but we do use the PREV/NEXT ops to iterate prefixes which requires
   the parent pointer to be maintained.
 * Buffer ids should be "circular", i.e. interpreted modulo the
   number of buffers in the ring. This allows "%*" to wrap at the
   end of the buffer list.
 * instead of 0EB to show the list of buffers, there should perhaps
   be a special TAB-completion (^G mode?) that completes only buffers
   in the ring. It should also display the numeric buffer ids.
 * properly support Unicode encodings and the character-based model
   * link against libncursesw if possible
   * translate documents to Unicode strings
   * a position refers to a character/codepoint
 * Progress indication in commandline cursor:
   Perhaps blinking or invisible?
 * Command to free Q-Register (remove from table).
   e.g. FQ (free Q). :FQ could free by QRegister prefix name.
 * autocompletion of long Q-Reg names
 * TECO syntax highlighting
 * multiline commandline
   * perhaps use Scintilla view as mini buffer.
     This means patching Scintilla, so it does not break lines
     on new line characters.
   * A Scintilla view will allow syntax highlighting
 * command line could highlight dead branches (e.g. gray them out)
 * improve GTK interface
   * shell-like popup widget
   * proper command-line widget (best would be a Scintilla view, s.a.)
   * speed improvements
   * color schemes
 * backup files, or even better Journal files:
   could write a Macro file for each modified file containing
   only basic commands (no loops etc.). it is removed when the file is
   saved. in case of an abnormal program termination the
   journal file can be replayed. This could be done automatically
   in the profile.
 * Add special Q-Register for dot:
   Would simplify inserting dot with string building and saving/restoring
   dot on the QReg stack
 * :EL command could also be used to convert all EOLs in the current
   buffer.
 * exclusive access to all opened files/buffers (locking):
   SciTECO will never be able to notice when a file has been
   changed externally. Also reversing a file write will overwrite
   any changes another process could have done on the file.
   Therefore open buffers should be locked using the flock(), fcntl()
   or lockf() interfaces. On Windows we can even enforce mandatory locks.
 * Touch restored save point files - should perhaps be configurable.
   This is important when working with Makefiles, as make looks
   at the modification times of files.
 * Instead of implementing split screens, it is better to leave
   tiling to programs dedicated to it (tmux, window manager).
   SciTECO could create pseudo-terminals (see pty(7)), set up
   one curses screen as the master of that PTY and spawn
   a process accessing it as a slave (e.g. urxvt -pty-fd).
   Each Scintilla view could then be associated with at most
   one curses screen.
   GTK+ would simply manage a list of windows.
 * Add a command for manipulating the clipboard.
   Can be done with ECxclip$ on Unix, but other platforms have
   better methods (e.g. PDCurses has clipboard extensions, GTK+
   has native clipboard support). On ncurses/UNIX we can fall back
   to spawning xclip or copy xclip's functionality.
   Unfortunately, not every UNIX has X11 (e.g. linux console,
   OS X). What do we do on those systems?
   This will also allow us to reverse clipboard modifications.
 * Add a test suite. Most bugs can be tested for regressions
   using a simple test suite that calls sciteco.
   Use Autotest for instance.

Optimizations:
 * Curses UI: Command line window can be modelled as a pad
   instead of a window. This simplifies things.
 * Instead of using RTTI to implement the immediate editing command
   behaviours in Cmdline::process_edit_cmd() depending on the current
   state, this could be modelled via virtual methods in State.
   This would almost eradicate Cmdline::process_edit_cmd() and the
   huge switch-case statement, would be more efficient (but who cares
   in this case?) and would allow us to -fno-rtti saving a few bytes.
   However, this would mean to make some more Cmdline methods public and
   it distributes command line behaviour all over SciTECO instead of
   concentrating it in the Cmdline class...
 * C++14 is supported by GCC 5 and supports new() and delete()
   operators with a size argument. Replacing these operators
   with versions using g_slice_alloc() and g_slice_free() should
   speed up things, especially Q-Register handling and the undo
   stack.
   This compiler capability should be checked by the build system.
   C++11 already allows sized allocators in a class.
   Testing shows that this does not speed up things on Linux
   and prevents freeing memory on command line termination
   (it would be glibc-specific).
   We should test whether it brings any benefit on Windows
   and implement with a build-time option.
 * Scintilla: SETDOCPOINTER resets representations, so we
   have to set SciTECO representations up again often.
   This should be patched in Scintilla.
 * commonly used (special) Q-Registers could be cached,
   saving the q-reg table lookup
 * refactor search commands (create proper base class)
 * refactor match-char state machine using MicroStateMachine class
 * simplify parser (static jump tables are unnecessary!)
 * search and other commands can be significantly optimized:
   in batch mode, or in loops/macros there is no need to rematch every character!
   -> immediate vs. non-immediate command execution
   * can be handled automatically in StateExpectString
   * but it requires to be able to determine whether we're in the
     command line macro stack frame and are executing the end of it.
 * batch mode can be optimized by preventing unnecessary allocations/deallocations
   for UNDO token creation. Check for undo.enabled in constructors like
   undo.push_msg|var() where the undo token destruction does not have any
   significant side effects.

Documentation:
 * Code docs (Doxygen). It's slowly getting better...
 * clean up/fix generate-docs.tes
